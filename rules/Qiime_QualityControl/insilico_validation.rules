

def parse_summary_tb(wildcards):
    checkpoint_output = checkpoints.combine_assembly_tables.get(**wildcards).output[0]
    tb=pd.read_csv(checkpoint_output,delimiter='\t')
    filenames=tb['AssemblyNames']
    expd=expand('assembly_gz/{sample}.fna.gz',sample=filenames)
    return expd



rule decompress_assemblies:
    conda: '../../envs/simulate_reads.yml'

    input: 'InSilico/assembly_gz/{sample}.fna.gz'

    output: 'InSilico/assembly_fna/{sample}.fna'

    shell: 'zcat {input[0]} > {output[0]}'


rule concat_scaffolds:
    input: 'InSilico/assembly_fna/{sample}.fna'

    output: temp('InSilico/concat/{sample}.fna')

    shell: "sed '1!{{/^>/d;}}' {input[0]} > {output[0]}"





rule Import :
    conda :
     "../../envs/QIIME2-2019.04.yml"
    input :
        assembly_finder("assembly_gz/{sample}.fna")
    output :
        "InSilico/2_denoised/{sample}_sequences.qza"
    threads :
        1
    shell :
         '''
        qiime tools import \
        --type 'FeatureData[Sequence]' \
        --input-path {input} \
        --output-path {output} 
        '''

rule Extract_V3V4 :
    conda :
        "../../envs/QIIME2-2019.04.yml"
    input :
        "InSilico/2_denoised/{sample}_sequences.qza"
    output :
        "InSilico/2_denoised/{sample}_V3V4.qza"
    params:
        primer_forward = config["forward_primer"],
        primer_reverse = config["reverse_primer"],
        length = config["length_max"]
    threads :
        1
    shell :
         '''
        qiime feature-classifier extract-reads \
        --i-sequences {input} \
        --p-f-primer {params[primer_forward]} \
        --p-r-primer {params[primer_reverse]} \
        --p-trunc-len {params[length]} \
        --o-reads {output} 
         '''

rule Export_Extract_V3V4 :
   conda :
        "../../envs/QIIME2-2019.04.yml"
   input :
        "InSilico/2_denoised/{sample}_V3V4.qza"
   output :
        "InSilico/2_denoised/full_dna-sequences.fasta"
   threads :
        1
   shell :
         '''
        qiime tools export \
        --input-path {input} \
        --output-path $(dirname {output}) && mv $(dirname {output})/dna-sequences.fasta {output}
        '''

rule Dereplication :
    conda :
        "../../envs/QIIME2-2019.04.yml"
    input :
        "InSilico/2_denoised/full_{sample}_dna-sequences.fasta"
    output :
        fasta = "InSilico/2_denoised/{sample}_dna-sequences.fasta",
        count = "InSilico/2_denoised/{sample}_count_table.txt"
    threads :
        1
    log :
        "InSilico/2_denoised/log/{sample}_fasta_count.log"
    shell :
         '''
        vsearch \
        --derep_fulllength {input} \
        --output {output[fasta]} \
        --uc {output[count]} \
        2> {log}
         '''
rule merge_fasta:
    input:
        assembly_finder("parse_summary_tb")
    output:
        "InSilico/2_denoides/merged_assemblies.fasta"
    shell:
        """
        cat {input} > {output}
        """


rule insilico_count_occurences :
    conda:
        "../../envs/QIIME1.yml"
    input:
        samples = "InSilico/2_denoised/{sample}_dna-sequences.fasta",
        rep_seq = "InSilico/2_denoides/merged_assemblies.fasta"
    output:
        "InSilico/2_denoised/countOTUs/{sample}_count_table.txt",
    log:
         "InSilico/2_denoised/countOTUs/{sample}_count_table.log"
    shell:
        '''
        vsearch --usearch_global {input[samples]} \
        -otutabout {output} \
        -id 0.97 \
        -strand plus \
        --db {input[rep_seq]} \
        2> {log}
        '''


### Format count table from vsearch
rule create_insilico_count_table :
    conda:
        "../../envs/r_visualization.yml"
    input:
        count_table_samples = expand("InSilico/2_denoised/countOTUs/{sample}_count_table.txt", sample = list(reads_local.index))
    output:
        count_table = "InSilico/2_denoised/count_table.txt"
    log:
        "InSilico/2_denoised/count_table.log"
    script:
        "../../rules/1_2_vsearch_OTUs/scripts/create_count_table_from_vsearch.R"


